= DailyBank Documentation Technique

La documentation technique de DailyBank est destinée aux programmeurs en charge de la maintenance de l'application. Elle décrit toutes les fonctionnalités développées dans une version donnée et contient tous les éléments essentiels à connaître pour comprendre le code écrit.

= Sommaire

- Présentation rapide de l'application
- Use Case
- Diagramme de classes
- Architecture
- Fonctionnalités


== Présentation rapide de l'application

Introduction :
DailyBank est une application bancaire complète qui permet aux utilisateurs de gérer leurs comptes bancaires et d'effectuer diverses opérations financières. Elle offre un ensemble de fonctionnalités adaptées aux différents rôles des utilisateurs, tels que les clients, les chefs d'agence et les guichetiers.

Gestion des clients :
DailyBank permet aux utilisateurs d'accéder à leurs comptes bancaires personnels et de consulter les informations relatives à leurs soldes, à l'historique des transactions et aux relevés. Ils peuvent également effectuer des transactions, y compris des virements entre leurs propres comptes ou vers des tiers.

Supervision et gestion des opérations :
Les chefs d'agence utilisent l'application pour superviser et gérer les activités au sein de leur agence. Ils ont accès à des fonctionnalités telles que la gestion des employés, la gestion des clients, la génération de rapports financiers et l'approbation des transactions.

Interactions avec les clients :
Les guichetiers, en tant qu'employés de la banque, utilisent l'application pour interagir directement avec les clients. Ils peuvent gérer les comptes clients, traiter les transactions, tels que les dépôts, les retraits et les virements, et clôturer les comptes sur demande. Ils assurent un service clientèle de qualité en respectant les politiques et les procédures bancaires.

Infrastructure technique :
Sur le plan technique, DailyBank utilise une base de données Oracle SQL pour stocker les informations des utilisateurs, telles que les détails des comptes, les transactions et les informations des clients. L'application est développée en utilisant JavaFX, une plateforme qui offre une interface utilisateur conviviale et réactive.

== Use Case

image:Images/uc-initialv2.svg


== Diagramme de classes

image:Images/dc-initialv2.svg


== Architecture

L'architecture de DailyBank se compose de plusieurs sous-systèmes qui interagissent entre eux pour fournir une solution complète. Les sous-systèmes sont les suivants :

Poste client : il s'agit de l'interface utilisateur de l'application. Il permet à l'utilisateur de communiquer avec le système, de visualiser les informations et de saisir des données.
Serveurs : il y a plusieurs serveurs dans le système, chacun avec un rôle spécifique. Les serveurs peuvent être physiques ou virtuels, et peuvent être répartis sur plusieurs machines. Les serveurs sont les suivants :
Serveur d'application : il s'agit du serveur qui exécute le code de l'application. Il peut être configuré pour fournir des services web ou d'autres types de services.
Serveur de base de données : il s'agit du serveur qui stocke les données de l'application. Il peut être utilisé pour stocker des données relationnelles, NoSQL ou d'autres types de données.
Le système peut dépendre de plusieurs ressources externes pour fonctionner correctement. Les ressources externes peuvent être des bibliothèques, des frameworks ou d'autres types de logiciels. Les ressources externes utilisées dans le système sont les suivantes :

Framework de développement : le système est développé en utilisant un framework spécifique. Le framework fournit des fonctionnalités de base pour le développement d'applications web, telles que la gestion des sessions utilisateur, la gestion des connexions de base de données et la gestion des formulaires.
Bibliothèque de connexion de base de données : le système utilise une bibliothèque spécifique pour se connecter à la base de données. La bibliothèque fournit des méthodes pour exécuter des requêtes SQL et pour récupérer les résultats.
L'application est structurée en packages selon les principes suivants :

Package de contrôleurs : ce package contient les classes qui contrôlent le flux d'exécution de l'application. Les contrôleurs sont responsables de récupérer les données saisies par l'utilisateur, de les traiter et de les stocker dans la base de données.
Package de modèles : ce package contient les classes qui représentent les données de l'application. Les modèles sont responsables de la validation des données saisies par l'utilisateur et de la communication avec la base de données.
Package de vues : ce package contient les classes qui définissent l'interface utilisateur de l'application. Les vues sont responsables de l'affichage des données de l'application et de la récupération des données saisies par l'utilisateur.
En plus de cela, le projet suit le modèle MVC (Modèle-Vue-Contrôleur), où les classes sont séparées en trois catégories selon leur rôle :

Le modèle représente les données de l'application, et est stocké dans une base de données. Les classes correspondantes sont regroupées dans le package "models".
La vue correspond à l'interface utilisateur, et est gérée par les classes du package "views". Chaque fenêtre est représentée par une classe distincte.
Le contrôleur est responsable de la coordination entre le modèle et la vue, et gère les actions de l'utilisateur. Les classes correspondantes sont regroupées dans le package "controllers". Il y a un contrôleur pour chaque fonctionnalité du logiciel, comme l'édition de clients, la fenêtre de connexion, etc.
== Fonctionalités

-1. Créditer/débiter un compte (Java et BD avec procédure stockée)

Explication : Cette fonctionnalité permet à un guichetier de créditer ou de débiter un compte bancaire d'un montant spécifique. La base de données doit être mise à jour avec la nouvelle valeur du solde du compte. L'opération doit être effectuée à l'aide d'une procédure stockée en Java.

Partie de use case réalisé : Cas d'utilisation "Gérer les comptes bancaires"

Scénarios éventuels :

Le guichetier n'a pas les autorisations nécessaires pour effectuer l'opération.
Le compte bancaire n'existe pas ou est fermé.
Le montant à créditer/débiter est supérieur au solde disponible.

Partie du diagramme de classes données nécessaires : Lecture et mise à jour du solde du compte bancaire.

Classes impliquées dans chaque package :

package "application.control" : Classe "TransactionController" (pour la mise à jour du solde)
package "model.orm" : Classe "Account" (pour la lecture du solde)
package "model.orm.exception" : Classe "AccountNotFoundException" (pour la gestion des erreurs)

Éléments essentiels à connaître :

Les procédures stockées en Java.
La gestion des erreurs en cas de montant supérieur au solde disponible.

-2. Créer un compte

Explication : Cette fonctionnalité permet à un guichetier de créer un nouveau compte bancaire pour un client. Le compte doit être associé à un client existant et avoir un solde initial de 0€.

Partie de use case réalisé : Cas d'utilisation "Gérer les comptes bancaires"

Scénarios éventuels :

Le guichetier n'a pas les autorisations nécessaires pour effectuer l'opération.
Le client associé au compte n'existe pas.

Partie du diagramme de classes données nécessaires :

Lecture et mise à jour de la liste des clients et des comptes bancaires.

Classes impliquées dans chaque package :

package "application.control" : Classe "AccountController" (pour la création d'un nouveau compte)
package "model.orm" : Classe "Client" (pour la création d'un nouveau compte)
package "model.orm" : Classe "Account" (pour la création d'un nouveau compte)
package "model.orm.exception" : Classe "ClientNotFoundException" (pour la gestion des erreurs)

Éléments essentiels à connaître :

La gestion des erreurs en cas de client inexistant.
La gestion des clés étrangères pour associer le compte au client.

-3. Effectuer un virement de compte à compte :

Explication : Le guichetier est en mesure de transférer de l'argent d'un compte bancaire à un autre compte bancaire appartenant au même client ou à un autre client.

Partie de use case réalisé : Cette fonctionnalité est couverte par le cas d'utilisation "Effectuer un transfert".

Scénarios éventuels : L'utilisateur doit spécifier le compte source, le compte destination, le montant et la date de transfert. Si le compte source ne dispose pas de fonds suffisants, le transfert doit être refusé. Une fois le transfert effectué, le système doit générer un reçu pour le client.

Partie du diagramme de classes données nécessaires : En lecture, le guichetier doit accéder aux informations des comptes source et destination pour s'assurer que le transfert est valide. En mise à jour, le guichetier doit mettre à jour les soldes des comptes source et destination.

Classes impliquées dans chaque package : Cette fonctionnalité implique les classes suivantes :

Package application.control : Classe GuichetierController pour initier le transfert et accéder aux informations des comptes.
Package model.orm : Classe Compte pour accéder aux informations de compte.
Package model.orm : Classe Client pour accéder aux informations de client.
Éléments essentiels à connaître : Le guichetier doit être formé aux politiques de transfert de la banque, notamment les limites de transfert, les frais de transfert et les restrictions de pays. De plus, la sécurité doit être prise en compte, en assurant que seuls les guichetiers autorisés peuvent effectuer des transferts et que les transferts sont effectués sur des comptes vérifiés.

Explication : Le guichetier doit être en mesure de clôturer un compte sur demande du client ou s'il constate que le compte ne répond plus aux exigences de la banque (compte inactif, compte frauduleux, etc.).

Partie de use case réalisé - scénarios éventuels :

Acteur : Guichetier
Description : Clôture d'un compte
Pré-conditions : Le guichetier doit avoir l'autorisation de clôturer un compte et le client doit avoir les documents nécessaires pour cette opération.
Scénarios :
Le guichetier identifie le compte à clôturer.
Il vérifie que le compte est éligible à la clôture.
Il demande au client les documents nécessaires pour la clôture.
Il saisit les informations nécessaires dans le système.
Il confirme la clôture du compte.
Il remet au client les documents nécessaires.
Partie du diagramme de classes données nécessaires : en lecture, en mise à jour :

En lecture : le guichetier doit pouvoir lire les informations liées au compte à clôturer, telles que le solde du compte et les opérations effectuées.
En mise à jour : le guichetier doit être en mesure de clôturer le compte dans le système.
Classes impliquées dans chaque package :

Package application.control : Classe GuichetierController pour accéder aux informations de compte à clôturer et pour le supprimer du système.
Package model.orm : Classe Compte pour récupérer continueà stocker les informations du compte à clôturer.


-5. Gérer les transactions

Explication : Le guichetier doit être en mesure de gérer les transactions pour les clients, notamment les dépôts, les retraits, les virements, etc.

Partie de use case réalisé - scénarios éventuels :

Acteur : Guichetier
Description : Gestion des transactions
Pré-conditions : Le client doit être identifié et authentifié, et le guichetier doit avoir les autorisations nécessaires pour effectuer la transaction demandée.
Scénarios :
Le client demande une transaction au guichetier.
Le guichetier identifie le compte du client et vérifie que les fonds sont disponibles.
Le guichetier effectue la transaction en utilisant le système informatique de la banque.
Le guichetier remet au client un reçu pour la transaction effectuée.
Partie du diagramme de classes données nécessaires : en lecture, en mise à jour :

En lecture : le guichetier doit pouvoir lire les informations liées au compte du client, telles que le solde du compte et les opérations effectuées.
En mise à jour : le guichetier doit être en mesure d'effectuer des transactions sur le compte du client.
Classes impliquées dans chaque package :

Package application.control : Classe GuichetierController pour accéder aux informations de compte du client et pour effectuer des transactions sur le compte du client.
Package model.orm : Classe Compte pour récupérer et mettre à jour les informations de compte du client.
